# Notes - Investigation scheduled reconcilation in the Percona MongoDB operator

The following documentation is specifically about the**Percona MongoDB operator**.  
I will however often refer to it as the *Percona operator* or even just *"the operator"*, since the architecture of the Percona database operators are very similar (and it makes typing easier).
I however have not checked if this is the same in each of the operators.

## Configuration of the schedule

Searching through the generated files resulted in the following:

- [bundle.yaml](https://github.com/percona/percona-server-mongodb-operator/blob/main/deploy/bundle.yaml#L19731)
- [cw-bundle.yaml](https://github.com/percona/percona-server-mongodb-operator/blob/main/deploy/cw-bundle.yaml#L19750)
- [cw-operator.yaml](https://github.com/percona/percona-server-mongodb-operator/blob/main/deploy/cw-operator.yaml#L46)
- [operator.yaml](https://github.com/percona/percona-server-mongodb-operator/blob/main/deploy/operator.yaml#L48)

These files contain a `RESYNC_PERIOD` env variable set to 5s, but it doesn't seem to be used (or it is at least not the value controlling the reconcile behavior).
TODO: look what sets the value and where it is used

### Finding the value in the code

[Code snippet](https://github.com/percona/percona-server-mongodb-operator/blob/82a1d9717b2854b04dd7e0e0778caaf54de68f60/pkg/controller/perconaservermongodb/psmdb_controller.go#L91-L105)

```go
return &ReconcilePerconaServerMongoDB{
  ...
  reconcileIn:            time.Second * 5,
  ...
}, nil
```

[psmdb_cntroller: Reconcile](https://github.com/percona/percona-server-mongodb-operator/blob/82a1d9717b2854b04dd7e0e0778caaf54de68f60/pkg/controller/perconaservermongodb/psmdb_controller.go#L237-L239)

```go
func (r *ReconcilePerconaServerMongoDB) Reconcile(ctx context.Context, request reconcile.Request) (reconcile.Result, error) {
 log := logf.FromContext(ctx)
 currentTime := time.Now()
 fmt.Println(currentTime)

 rr := reconcile.Result{
  RequeueAfter: r.reconcileIn,
 }
  ...
}
```

Changing the value confirms that this is what is controlling the scheduled behavior.

### Other cases

We however can find 2 other cases within the code where the RequeueAfter flag is set:

1. `ReconcilePerconaServerMongoDBBackup::Reconcile` where it is returned by default and hardcoded at 5 seconds
2. `ReconcilePerconaServerMongoDBRestore::Reconcile` where it is returned by default and hardcoded at 5 seconds

## Reason behind the schedule

### Kubebuilder book

Looking at the reasons highlighted in ["Why should you use it (scheduled reconcilation) and why not?"](./configuration_schedule.md#why-should-you-use-it-and-why-not), we can not link the current operator to this group:

- **Observing External Systems:** the operator is heavily integrated and creates events for the proper situations
- **Time-Based Operations:** only things that come to mind are certificate renewals or backups, but these wouldn't have to happen every 5s by default
- **Handling Errors or Delays:** does happen in this case, if an error occurs, then the 5s interval is once again activated, but doesn't explain why it happens on success as well

The operator thus falls under none of these categories.

### TL:DR

- Through the use of Git Blame: possibly to support sidecar containers, since these often modify the file system without changing any of the Kubernetes resources.
- Through PR in the Percona MongoDB repo: In order to manage secondary resources (generated by the CR) due to not registering proper watches

### Research

#### Online forums

[Reddit - r/Kubernetes: Kubernetes operators reconcile times constants](https://www.reddit.com/r/kubernetes/comments/11dcys9/kubernetes_operators_reconcile_times_constants/?rdt=65336)

#### Using our hypothesis, the code and some testing

We thus go back to our hypothesis: the operator receives a large amount of events and it is more efficient to handle them as a group at a set interval, then to handle each one by one.

##### Searching for keywords through code

This prompts searching through the code for which events are generated within the operator, which events wake the operator and which are requested by other means.

#### Using Git Blame

1. Git blame returns [2acb13cd6 - 2024-03-27 - K8SPSMDB-1061: Refactor reconcileStatefulSet (#1386)](https://github.com/percona/percona-server-mongodb-operator/commit/2acb13cd69f4fa217f983229aca28ac4b0695d1a) as the commit where return rr gets added within the ReconcilePerconaServerMongoDB::Reconcile function
2. Code still present in parent commit [08e1672](https://github.com/percona/percona-server-mongodb-operator/blob/8719612fd6217b29f5a36faa536a31203002740b/pkg/controller/perconaservermongodb/psmdb_controller.go#L567)
3. Git blame returns [61eb6e381 - 2019-01-16 - Secrets and keys](https://github.com/percona/percona-server-mongodb-operator/commit/61eb6e3816af89d153a9638ce2bc377a5e8756d7)
4. In the parent commit [461cf44 - 2019-01-15 - Set psmdb option defaults](https://github.com/percona/percona-server-mongodb-operator/commit/461cf447abd043c638980a900b56d330c933c014) **rr isn't returned by default anymore**
   - The `r.reconcileIn` only gets used once: inside rr and rr only gets returned on error
   - Another value `r.ResyncPeriod` is introduced and used within the `AnsibleOperatorReconciler` and `HelmOperatorReconciler` both returning by default

Due to the not very documented inclusion of the default return of rr, we can conclude that this probably came from another of the Percona operators.

#### Looking at the other Percona operators

- **[Percona PostgreSQL operator:](https://github.com/percona/percona-server-mysql-operator)** Only uses requeueAfter in the **Handling Errors or Delays** case
- **[Percona MySQL operator:](https://github.com/percona/percona-server-mysql-operator)** also returns rr by default ([src](https://github.com/percona/percona-server-mysql-operator/blob/4026c739aa71a32beda7190b3df07b21a4877c23/pkg/controller/ps/controller.go#L109))
  - This was added in commit [da19411 - 2021-12-14](https://github.com/percona/percona-server-mysql-operator/commit/da19411ab2e75bf19cf2d460e604efc5aab45406#diff-1dce8a8601aa2e5d1ff49edf5f967066f86587214862ff733354f7ed0a6e7d8fR96) from a [PR: [K8SPS-29] Support sidecars for MySQL pods](https://github.com/percona/percona-server-mysql-operator/pull/22)
  - Following which commit within the PR was responsible for the change, brings us to [c822136 - fix tests](https://github.com/percona/percona-server-mysql-operator/commit/c822136386b05984b8d68a04982419981d65a939#diff-1dce8a8601aa2e5d1ff49edf5f967066f86587214862ff733354f7ed0a6e7d8fR96)

This does bring the idea that maybe the sidecar pods could bring changes in the system which are not accounted for within Kubernetes, forcing our system to reconcile quite frequently to keep up to date.
This however doesn't seem like a satisfactory result.

#### Looking for clues in the describe of the custom resource the operator manages

`kubectl describe perconaservermongodbs.psmdb.percona.com minimal-cluster` doesn't contain a value that follows our schedule.

#### Looking through Github Pull requests

(Issues resulted in nothing)

These are PRs from people attempting to remove the behavior which ultimately failed due to failing to meet some of the constraints.

- [MongoDB operator: PR #880](https://github.com/percona/percona-server-mongodb-operator/pull/880)
  - Attempts to solve the issues with secondary resources by only rescheduling when required for one of those resources within the reconcile loop
  - Doesn't account for issues in the secondary resources after the startup
- [MongoDB operator: PR #1068](https://github.com/percona/percona-server-mongodb-operator/pull/1068)
  - Adds extra check for the state of the pods
  - Blocks the cluster from starting if the app is not seen as ready (and reschedules)
  - Also went through the git blaming process and came to the same conclusion that it wasn't documented
  - Same problem as above!

The TL:DR seems to be that for complex operators with many moving parts, it can be quite hard to register watches for every single secondary resource.
The Percona MongoDB operator is structured in a very understandable way: the reconcile function calls other reconcile functions that specifically are used to check the secondary resources.
These functions are prepended with `reconcile` e.g. `r.reconcileReplsets`.

One of the solutions the maintainers propose is the use of a watch with [`EnqueueRequestForOwner`](https://pkg.go.dev/sigs.k8s.io/controller-runtime/pkg/handler#EnqueueRequestForOwner),
but this method won't work which I will explain later.

> Enqueues a reconcile.Request containing the Name and Namespace of the Owner of the object in the Event. This will cause owner of the object that was the source of the Event (e.g. the owner object that created the object) to be reconciled.

This uses the `OwnerReference` set in a resource, looks if it is a controller (via the `controller=true` flag) and then calls that reconcile function.
Using `kubectl describe` (or via the minikube dashboard through the edit button), allows us to look at the OwnerReferences set.

The operator itself consists of the following:

| **Kind**               | **Resource Names**                              |
|------------------------|-------------------------------------------------|
| **Pod** | `percona-server-mongodb-operator-6777b4c85b-tbrd5` |
| **ReplicaSet** | `percona-server-mongodb-operator-6777b4c85b` |
| **Deployment** | `percona-server-mongodb-operator` |
| **Custom Resource Definition (CRD)** | `perconaservermongodbs.psmdb.percona.com` <br> `perconaservermongodbbackups.psmdb.percona.com` <br> `perconaservermongodbrestores.psmdb.percona.com` |
| **Role** | `percona-server-mongodb-operator` |
| **RoleBinding** | `service-account-percona-server-mongodb-operator` |
| **ServiceAccount** | `percona-server-mongodb-operator` |

The CR creation (through cr-minimal.yaml) prompts the following resources to be created however:

| **Kind**               | **Resource Names**                              | **OwnerReference to CR** |
|------------------------|-------------------------------------------------|:------------------------:|
| **Pod**              | `minimal-cluster-cfg-0` <br> `minimal-cluster-mongos-0` <br> `minimal-cluster-rs0-0` | ❌ <br> ❌ <br> ❌ |
| **Service**          | `minimal-cluster-cfg` <br> `minimal-cluster-mongos` <br> `minimal-cluster-rs0` | ❌ <br> ❌ <br> ❌ |
| **StatefulSet**      | `minimal-cluster-cfg` <br> `minimal-cluster-mongos` <br> `minimal-cluster-rs0` | ✅ <br> ✅ <br> ✅ |
| **Secret**           | `internal-minimal-cluster-users` <br> `minimal-cluster` <br> `minimal-cluster-mongodb-encryption-key` <br> `minimal-cluster-mongodb-keyfile` <br> `minimal-cluster-ssl` <br> `minimal-cluster-ssl-internal` | ❌*<br> ❌* <br> ❌* <br> ✅ <br> ✅ |
| **Persistent Volume Claim (PVC)** | `mongod-data-minimal-cluster-cfg-0` <br> `mongod-data-minimal-cluster-rs0-0` | ❌ |

> [!NOTE]
> (*) does have the operator set as the manager for its field which are marked as "managedFields"

> [!NOTE]
> Each of these resources has labels indicating it is part is a secondary resource to our CR:
>
> - app.kubernetes.io/component: mongod
> - app.kubernetes.io/instance: minimal-cluster
> - app.kubernetes.io/managed-by: percona-server-mongodb-operator
> - app.kubernetes.io/name: percona-server-mongodb
> - app.kubernetes.io/part-of: percona-server-mongodb

> [!NOTE]
> This list was created using `kubectl get all -n <namespace>`  
> And then expanded using gets for ConfigMaps, Secrets, PersistentVolumeClaims (PVCs), Custom Resource Definitions (CRDs), Roles, RoleBindings and Service Accounts

Coming back to the reason why `EnqueueRequestForOwner` wouldn't work: not every resource has it set to the CR.
The table seems to indicate that only the parent resources (using parent instead of primary to avoid confusion with the scope) have the ownerReference metadata, while their child resources don't (for example StatefulSet -> Pod). This problem can be avoided by only querying the parent resources however and using them to call the reconcile.
Things get even more difficult when we take into account that there are 3 CR's: due to backup (PerconaServerMongoDBBackup) and restore (PerconaServerMongoDBRestore).
Keep in mind that all of this still follows the Kubernetes pattern where it doesn't provide the event to the reconcile function, but lets the operator re-evaluate the entire status vs. spec and act accordingly

We could however make use of [EnqueueRequestsFromMapFunc](https://pkg.go.dev/sigs.k8s.io/controller-runtime/pkg/handler#EnqueueRequestsFromMapFunc) instead.
